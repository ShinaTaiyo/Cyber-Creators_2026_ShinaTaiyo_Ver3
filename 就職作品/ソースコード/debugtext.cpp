//====================================================================================================================
//
//２０２５年１月１０日：C＋＋のデバッグ表示を作る[debugtext.cpp]
//Author:ShinaTaiyo
//
//====================================================================================================================

//==============================================================
//インクルード
//==============================================================
#include "debugtext.h"
#include "manager.h"
#include "renderer.h"
//====================================================================================================================

//==============================================================
//静的メンバ宣言
//==============================================================
LPD3DXFONT CDebugText::s_pFont = nullptr;//フォントへのポインタ
string CDebugText::s_DrawString;    //デバッグ表示用文字列
bool CDebugText::s_bDispDebug = false;   //デバッグ表示をするかどうか
//====================================================================================================================

//==============================================================
//コンストラクタ
//==============================================================
CDebugText::CDebugText()
{
    s_DrawString.reserve(4096);//事前に必要な配列を確保しておく
    
#ifndef _DEBUG
    s_bDispDebug = false;
#else
    s_bDispDebug = true;
#endif // !_DEBUG

}
//====================================================================================================================

//==============================================================
//デストラクタ
//==============================================================
CDebugText::~CDebugText()
{

}
//====================================================================================================================

//==============================================================
//初期化処理
//==============================================================
HRESULT CDebugText::Init()
{
    HRESULT hr = D3DXCreateFont(
        CManager::GetRenderer()->GetDevice(),                    // デバイスオブジェクト
        18,                          // フォントの高さ
        0,                           // 幅（0は自動設定）
        FW_BOLD,                     // 太さ
        1,                           // ミップマップレベル（通常1）
        FALSE,                       // イタリックなし
        DEFAULT_CHARSET,             // 文字セット
        OUT_DEFAULT_PRECIS,          // 出力精度
        ANTIALIASED_QUALITY,         // 描画品質
        DEFAULT_PITCH | FF_DONTCARE, // ピッチとファミリー
        "Arial",                     // フォント名（"Arial" は、一般的に使われるサンセリフ（sans-serif）書体のフォント名です。このフォントは、多くのオペレーティングシステムやアプリケーションでデフォルトのフォントとして利用されることがあり、見やすくて汎用性の高いデザインが特徴です。
        &s_pFont                     // 作成したフォントオブジェクト
    );

    if (FAILED(hr))
    {
        OutputDebugString("フォントの作成に失敗！");
        return hr;
    }

	return S_OK;
}
//====================================================================================================================

//==============================================================
//終了処理
//==============================================================
void CDebugText::Uninit()
{
	if (s_pFont != nullptr)
	{//フォントの開放
        s_pFont->Release();
        s_pFont = nullptr;
	}

    s_DrawString.clear();         //メモリを初期化
    s_DrawString.shrink_to_fit(); //メモリを破棄
}
//====================================================================================================================

//==============================================================
//更新処理
//==============================================================
void CDebugText::Update()
{

}
//====================================================================================================================

//==============================================================
//描画処理
//==============================================================
void CDebugText::Draw()
{
    RECT rect = { 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT };
    if (s_bDispDebug == true)
    {//デバックモードがオンの時
     //テキストの描画
        s_pFont->DrawText(NULL, s_DrawString.c_str(), -1, &rect, DT_LEFT, D3DCOLOR_RGBA(255, 255, 255, 255));
        s_DrawString.clear();//メモリを初期化（Printf用の関数が1fで呼ばれた分だけ表示するため)
    }
}
//====================================================================================================================

//==============================================================
//デバッグテキストを入力する
//==============================================================
void CDebugText::PrintDebugText(const string Format, ...)
{
    if (s_bDispDebug == true)
    {
        va_list args;         //可変長引数を格納するための型
        va_start(args, Format);//va_listを初期化し、可変長引数の前の引数を指定

        std::ostringstream oss;  // 文字列を格納するためのオブジェクト
        //*「size_t」型は、符号なし整数型！負の値になるケースが存在しないので、配列などを数える時に便利
        //前置きインクリメントは、後置きインクリメントと違い、そのものをインクリメントする。後起きは、コピーを作成してから値を増やし、その値を返すので、非効率
        for (size_t i = 0; i < Format.size(); ++i) {
            if (Format[i] == '%' && i + 1 < Format.size()) {
                ++i;  // フォーマット指定子に進む
                switch (Format[i]) {
                case 'd': { // 整数
                    int value = va_arg(args, int);//可変長引数リストの次の引数（int)を取得
                    oss << value;
                    break;
                }
                case 'f': { // 浮動小数点数
                    double value = va_arg(args,double);//可変長引数リストの次の引数（double)を取得
                    oss << value;
                    break;
                }
                case 's': { // 文字列
                    const char* value = va_arg(args, const char*);//可変長引数リストの次の引数（const char*)を取得
                    oss << value;
                    break;
                }
                default://指定子が存在しない場合
                    oss << '%' << Format[i]; // フォーマット指定子をそのまま出力
                    break;
                }
            }
            else {
                oss << Format[i];  // 通常の文字を出力
            }
        }

        s_DrawString.append(oss.str());//可変長引数を反映した文字列を連結する

        va_end(args);//可変長引数リストの使用を終了する
    }
}
//====================================================================================================================