//===================================================================================================================
//
//１１月１０日：プレイヤーのアクションモードクラスを作る[player_actionmode.cpp]
//Author:ShinaTaiyo
//
//===================================================================================================================

//===============================================================
//インクルード
//===============================================================
#include "player_actionmode.h"
#include "texture.h"
#include "calculation.h"
#include "debugtext.h"
#include "manager.h"
#include "collision.h"
#include "effect.h"
#include "enemy.h"
#include "meshorbit.h"
#include "attack.h"
#include "input.h"
#include "lockon.h"
#include "wire.h"
#include "player.h"
#include "game.h"
#include "tutorial.h"
#include "particle.h"
#include "sound.h"
#include "score.h"
#include "wire_head.h"
#include "camera.h"
//===================================================================================================================

//******************************************************************************************************************************************************
//プレイヤー移動クラス
//******************************************************************************************************************************************************

//=====================================================================================================
//コンストラクタ
//=====================================================================================================
CPlayerMove::CPlayerMove() : m_bIsLanding(false), m_bDodge(false)
{

}
//======================================================================================================================================================

//=====================================================================================================
//デストラクタ
//=====================================================================================================
CPlayerMove::~CPlayerMove()
{

}
//======================================================================================================================================================

//=====================================================================================================
//移動処理
//=====================================================================================================
void CPlayerMove::MoveProcess(CPlayer* pPlayer)
{
	if (m_bDodge == false)
	{//回避中なら絶対に通常移動はさせない
		const D3DXVECTOR3& Move = pPlayer->GetMoveInfo().GetMove();//移動量
		D3DXVECTOR3 AddMove = D3DXVECTOR3(0.0f, 0.0f, 0.0f);       //加算する移動量
		bool bMove = false;                                        //移動しているかどうか
		CObjectX::RotInfo& RotInfo = pPlayer->GetRotInfo();        //向き情報
		D3DXVECTOR3 RotAim = RotInfo.GetRotAim();                  //目的の向きを取得
																   //目的の向き
		CObjectX::PosInfo& PosInfo = pPlayer->GetPosInfo();        //位置情報
		D3DXVECTOR3 NextPos = PosInfo.GetPos();                    //位置
		CCamera* pCamera = CManager::GetCamera();                  //カメラ
		//移動しているかどうかを取得。移動しているならAddMoveに値が入る
		bMove = CCalculation::CaluclationMove(true, NextPos,AddMove, 10.0f, CCalculation::MOVEAIM_XZ, RotAim.y);

		//移動方向にプレイヤーの向きを合わせる
		pPlayer->GetRotInfo().SetRot(D3DXVECTOR3(pPlayer->GetRotInfo().GetRot().x,pCamera->GetRot().y, pPlayer->GetRotInfo().GetRot().z));

		pPlayer->GetMoveInfo().SetUseInteria(true, CObjectX::GetNormalInertia());//慣性を使用する
		pPlayer->GetMoveInfo().SetUseGravity(true, CObjectX::GetNormalGravity());//重力を使用する

		if (bMove == true)
		{//移動していたら
			pPlayer->SetNextMotion(1);//移動モーションを次のモーションに指定する
			pPlayer->GetMoveInfo().SetMove(AddMove + D3DXVECTOR3(0.0f, Move.y, 0.0f));
			CGame::GetTutorial()->SetSuccessCheck(CTutorial::CHECK::MOVE);//移動チュートリアルを完了
		}
		else
		{
			pPlayer->SetNextMotion(0);//動いていないので、初期モーションのニュートラルに設定
		}
	}
}
//======================================================================================================================================================

//=====================================================================================================
//ジャンプ処理
//=====================================================================================================
void CPlayerMove::JumpProcess(CPlayer* pPlayer)
{
	CObjectX::CollisionInfo& CollisionInfo = pPlayer->GetCollisionInfo();               //当たり判定情報を取得する
	CObjectX::CollisionInfo::State& CollisionState = CollisionInfo.GetState();          //当たり判定状態を取得する
	if (CollisionState.GetLanding())
	{//地面にいるならジャンプ
		pPlayer->GetMoveInfo().SetUseGravity(true, CObjectX::GetNormalGravity());//重力を使用する
		if (CManager::GetInputJoypad()->GetTrigger(CInputJoypad::JOYKEY::A) || CManager::GetInputKeyboard()->GetTrigger(DIK_SPACE))
		{//スペースキー又はジョイパッドのAボタンを押していたら
			CGame::GetTutorial()->SetSuccessCheck(CTutorial::CHECK::JUMP);//ジャンプのチュートリアルを完了
			pPlayer->GetMoveInfo().SetMove(D3DXVECTOR3(pPlayer->GetMoveInfo().GetMove().x, 20.0f, pPlayer->GetMoveInfo().GetMove().z));//移動量を設定
		}
	}
}
//======================================================================================================================================================

//=====================================================================================================
//回避処理
//=====================================================================================================
void CPlayerMove::DodgeProcess(CPlayer* pPlayer)
{
	CInputJoypad* pInput = CManager::GetInputJoypad();//ジョイパッド入力情報を取得
	if ((pInput->GetLT_Trigger() || CManager::GetInputKeyboard()->GetTrigger(DIK_LSHIFT)) && m_bDodge == false)
	{//LSHIFTキー又はジョイパッドのLトリガーボタンを押していたら
		m_bDodge = true;//回避している
		//移動量を設定
		pPlayer->GetMoveInfo().SetMove(D3DXVECTOR3(pPlayer->GetMoveInfo().GetMove().x * s_fACCELL_PARAM, pPlayer->GetMoveInfo().GetMove().y, pPlayer->GetMoveInfo().GetMove().z * s_fACCELL_PARAM));
		pPlayer->GetMoveInfo().SetUseInteria(true, 0.1f);//慣性をかなり弱くする
		CGame::GetTutorial()->SetSuccessCheck(CTutorial::CHECK::DASH);//回避のチュートリアルを完了
	}

	//平均速度を計算
	float fAverageSpeed = (fabsf(pPlayer->GetMoveInfo().GetMove().x) + fabsf(pPlayer->GetMoveInfo().GetMove().z)) / 2;

	if (fAverageSpeed < 0.51f && m_bDodge == true)
	{//平均速度が0.51fを下回っていて、回避状態なら
		m_bDodge = false;//回避状態をオフにすrう
		pPlayer->GetMoveInfo().SetUseInteria(true, CObjectX::GetNormalInertia());//通常の慣性に戻す
	}
}

//======================================================================================================================================================

//******************************************************************************************************************************************************
//プレイヤー普通移動クラス
//******************************************************************************************************************************************************

//=====================================================================================================
//コンストラクタ
//=====================================================================================================
CPlayerMove_Normal::CPlayerMove_Normal()
{

}
//======================================================================================================================================================

//=====================================================================================================
//デストラクタ
//=====================================================================================================
CPlayerMove_Normal::~CPlayerMove_Normal()
{
}
//======================================================================================================================================================

//=====================================================================================================
//移動処理
//=====================================================================================================
void CPlayerMove_Normal::MoveProcess(CPlayer* pPlayer)
{
	CPlayerMove::MoveProcess(pPlayer);//移動処理

	CPlayerMove::DodgeProcess(pPlayer);//回避処理

	CPlayerMove::JumpProcess(pPlayer);//ジャンプ処理
}
//======================================================================================================================================================


//******************************************************************************************************************************************************
//プレイヤーダイブ移動クラス
//******************************************************************************************************************************************************

//=====================================================================================================
//コンストラクタ
//=====================================================================================================
CPlayerMove_PrepDive::CPlayerMove_PrepDive(CPlayer* pPlayer)
{

}
//======================================================================================================================================================

//=====================================================================================================
//デストラクタ
//=====================================================================================================
CPlayerMove_PrepDive::~CPlayerMove_PrepDive()
{

}
//======================================================================================================================================================

//=====================================================================================================
//移動処理
//=====================================================================================================
void CPlayerMove_PrepDive::MoveProcess(CPlayer* pPlayer)
{
	CPlayerMove::MoveProcess(pPlayer);//通常移動

	CPlayerMove::DodgeProcess(pPlayer);//回避移動

	CPlayerMove::JumpProcess(pPlayer);//ジャンプ移動
}
//======================================================================================================================================================

//******************************************************************************************************************************************************
//プレイヤーダイブ移動クラス
//******************************************************************************************************************************************************

//=====================================================================================================
//静的メンバ宣言
//=====================================================================================================

//=====================================================================================================
//コンストラクタ
//=====================================================================================================
CPlayerMove_Dive::CPlayerMove_Dive() : m_DiveMove(D3DXVECTOR3(0.0f,0.0f,0.0f))
{

}
//======================================================================================================================================================

//=====================================================================================================
//デストラクタ
//=====================================================================================================
CPlayerMove_Dive::~CPlayerMove_Dive()
{

}
//======================================================================================================================================================

//=====================================================================================================
//移動処理
//=====================================================================================================
void CPlayerMove_Dive::MoveProcess(CPlayer* pPlayer)
{
	CWireHead* pWireHead = pPlayer->GetWire()->GetWireHead();//ワイヤーの頭を取得

	pPlayer->GetMoveInfo().SetMove(CCalculation::Calculation3DVec(pPlayer->GetPosInfo().GetPos(),pWireHead->GetPosInfo().GetPos(),s_fDIVEMOVE));//目的地に達するまで狙い続ける

	if (pPlayer->IsDamaged())
	{//ダイブ移動中にダメージを受けたら射撃モードの初期状態に戻す（ダイブ攻撃は強力な攻撃なので、ノーリスクで突撃させたくないから）
		pPlayer->SetInitialActionMode(CPlayer::ACTIONMODE::SHOT);
	}
}
//======================================================================================================================================================

//******************************************************************************************************************************************************
//プレイヤー移動できないクラス
//******************************************************************************************************************************************************

//=====================================================================================================
//コンストラクタ
//=====================================================================================================
CPlayerMove_Dont::CPlayerMove_Dont()
{

}
//======================================================================================================================================================

//=====================================================================================================
//デストラクタ
//=====================================================================================================
CPlayerMove_Dont::~CPlayerMove_Dont()
{

}
//======================================================================================================================================================

//=====================================================================================================
//移動処理
//=====================================================================================================
void CPlayerMove_Dont::MoveProcess(CPlayer* pPlayer)
{
	pPlayer->GetMoveInfo().SetMove(D3DXVECTOR3(0.0f, pPlayer->GetMoveInfo().GetMove().y, 0.0f));
}
//======================================================================================================================================================

//******************************************************************************************************************************************************
//プレイヤー攻撃できるクラス
//******************************************************************************************************************************************************

//=====================================================================================================
//静的メンバ宣言
//=====================================================================================================
const float CPlayerAttack_Shot::s_fNORMAL_SHOTSPEED = 50.0f;

//=====================================================================================================
//コンストラクタ
//=====================================================================================================
CPlayerAttack_Shot::CPlayerAttack_Shot()
{

}
//======================================================================================================================================================

//=====================================================================================================
//デストラクタ
//=====================================================================================================
CPlayerAttack_Shot::~CPlayerAttack_Shot()
{

}
//======================================================================================================================================================

//=====================================================================================================
//攻撃処理
//=====================================================================================================
void CPlayerAttack_Shot::AttackProcess(CPlayer* pPlayer)
{
	CLockon* pLockon = pPlayer->GetLockOn();                                                                             //ロックオンへのポインタ
	D3DXVECTOR3 ShotPos = pPlayer->GetPosInfo().GetPos() + D3DXVECTOR3(0.0f, pPlayer->GetSizeInfo().GetVtxMax().y, 0.0f);//射撃開始位置
	D3DXVECTOR3 Move = CCalculation::Calculation3DVec(ShotPos, pLockon->GetNearRayColObjPos(), s_fNORMAL_SHOTSPEED);     //射撃開始位置とロックオンのレイが当たった位置への移動量を求める
	CAttackPlayer* pAttackPlayer = nullptr;                                                                              //プレイヤー攻撃へのポインタ
	CInputKeyboard* pInputKeyboard = CManager::GetInputKeyboard();//キー入力情報へのポインタ
	CInputJoypad* pInputJoypad = CManager::GetInputJoypad();      //ジョイパッド入力情報へのポインタ
	CInputMouse* pInputMouse = CManager::GetInputMouse();         //マウス入力情報へのポインタ
	CSound* pSound = CManager::GetSound();                        //サウンド情報へのポインタ
	if (pInputKeyboard->GetTrigger(DIK_J) == true || pInputJoypad->GetRT_Repeat(4) == true ||
		pInputMouse->GetMouseLeftClickRepeat(4) == true)
	{//Jキー又はジョイパッド右トリガーボタン又はマウスの左クリックボタンを押していたら
		//弾を生成
		pAttackPlayer = CAttackPlayer::Create(CAttack::ATTACKTYPE::BULLET,CAttack::TARGETTYPE::ENEMY,CAttack::COLLISIONTYPE::SQUARE,true,true,3,0,45,ShotPos, pPlayer->GetRotInfo().GetRot(), Move, D3DXVECTOR3(1.0f, 1.0f, 1.0f));
		pAttackPlayer->GetMoveInfo().SetUseInteria(false, CObjectX::GetNormalInertia());//慣性を使用しない
		pAttackPlayer->GetLifeInfo().SetAutoSubLife(true);                              //体力がなくなったら死亡フラグを設定する
		pAttackPlayer->SetHitOtherThanLibing(true);                                     //建物にも当たる

		pSound->PlaySoundB(CSound::SOUND_LABEL::SE_SHOT_001);                           //射撃効果音を出す
		CGame::GetTutorial()->SetSuccessCheck(CTutorial::CHECK::SHOT);		            //射撃チュートリアル完了
	}

	if (pInputJoypad->GetRT_Press())
	{//ジョイパッドのプレスボタンを押していたら
		pPlayer->SetNextMotion(2);//攻撃ボタンを押している限り、次のモーションは攻撃モーションになる
	}
}
//======================================================================================================================================================

//******************************************************************************************************************************************************
//プレイヤー攻撃できないクラス
//******************************************************************************************************************************************************

//=====================================================================================================
//コンストラクタ
//=====================================================================================================
CPlayerAttack_Dont::CPlayerAttack_Dont()
{

}
//======================================================================================================================================================

//=====================================================================================================
//デストラクタ
//=====================================================================================================
CPlayerAttack_Dont::~CPlayerAttack_Dont()
{

}
//======================================================================================================================================================

//=====================================================================================================
//攻撃処理
//=====================================================================================================
void CPlayerAttack_Dont::AttackProcess(CPlayer* pPlayer)
{
	//何もしない
}
//======================================================================================================================================================

//******************************************************************************************************************************************************
//プレイヤーダイブ攻撃クラス
//******************************************************************************************************************************************************

//=====================================================================================================
//コンストラクタ
//=====================================================================================================
CPlayerAttack_Dive::CPlayerAttack_Dive()
{

}
//======================================================================================================================================================

//=====================================================================================================
//デストラクタ
//=====================================================================================================
CPlayerAttack_Dive::~CPlayerAttack_Dive()
{

}
//======================================================================================================================================================

//=====================================================================================================
//攻撃処理
//=====================================================================================================
void CPlayerAttack_Dive::AttackProcess(CPlayer* pPlayer)
{
	CUi* pDivePossibleUi = pPlayer->GetDivePossibleNum();//ダイブ可能回数表示へのポインタ
	CUi* pDiveGaugeFrameUi = pPlayer->GetDiveGaugeFrame();//ダイブゲージフレームへのポインタ

	//ダイブゲージの機能の取得
	CUIComposite_Container* pDiveGaugeFrameUiCompositeContainer = pDiveGaugeFrameUi->GetUiCompositeContainer();                //ゲージフレームのコンポジットパターンのコンテナを取得する
	CUIComposite_Gauge* pDiveGaugeUi_CompositeGauge = pDiveGaugeFrameUiCompositeContainer->GetChildren<CUIComposite_Gauge>();  //ゲージの機能を取得する

	//ダイブ可能回数の機能の取得
	CUIComposite_Container* pDivePossibleUiCompositeContainer = pDivePossibleUi->GetUiCompositeContainer();                           //ダイブ可能回数のUIのコンポジットパターンのコンテナを取得する
	CUIComposite_Numeric* pDivePossibleUiComposite_Numeric = pDivePossibleUiCompositeContainer->GetChildren<CUIComposite_Numeric>();  //数字表示の機能を取得する

	if (pDiveGaugeUi_CompositeGauge != nullptr)
	{//ゲージ情報が存在していたら
		CGauge* pDiveGauge = pDiveGaugeUi_CompositeGauge->GetGauge();         //ダイブゲージフレームのゲージへのポインタ
		CSound* pSound = CManager::GetSound();                                //サウンド情報へのポインタ
		CWireHead* pWireHead = pPlayer->GetWire()->GetWireHead();             //ワイヤーの頭へのポインタ
		if (pDivePossibleUiComposite_Numeric->GetValue() > 0)
		{//ダイブゲージがたまっていたら爆発攻撃を発動
			//爆発攻撃を生成
			CAttackPlayer* pAttackPlayer = CAttackPlayer::Create(CAttack::ATTACKTYPE::EXPLOSION, CAttack::TARGETTYPE::ENEMY, CAttack::COLLISIONTYPE::SQUARE, false, true, 50, 30, 100, pPlayer->GetPosInfo().GetPos(), D3DXVECTOR3(0.0f, 0.0f, 0.0f), D3DXVECTOR3(0.1f, 0.1f, 0.1f),
				D3DXVECTOR3(1.0f, 1.0f, 1.0f));
			pAttackPlayer->GetSizeInfo().SetUseAddScale(D3DXVECTOR3(0.4f, 0.4f, 0.4f), true);                                 //拡大率の加算をする
			pAttackPlayer->SetColor(D3DXCOLOR(1.0f, 1.0f, 0.0f, 1.0f), 2, false, false, false);                               //色合いを設定
			pAttackPlayer->GetLifeInfo().SetUseRatioLifeAlpha(true);                                                          //体力割合に応じて透明度を変更
			pAttackPlayer->SetCollisionRelease(false);                                                                        //衝突したときに破棄しない
			CGame::GetTutorial()->SetSuccessCheck(CTutorial::CHECK::TAKEDIVE);                                                //ダイブ攻撃のチュートリアルを完了
			pDivePossibleUiComposite_Numeric->SetValue(pDivePossibleUiComposite_Numeric->GetValue() - 1, pDivePossibleUi);    //ダイブ可能回数を減らす
			CManager::GetSound()->PlaySoundB(CSound::SOUND_LABEL::SE_EXPLOSION_000);

			//目的の向きまで少しづつ動かす（カメラの前は-D3DX_PI * 0.5f,プレイヤーはデフォルトの向きが異なるので、Rot.y + D3DX_PI)
			CManager::GetCamera()->ChengeState(DBG_NEW CCameraState_TurnAround(D3DXVECTOR3(-D3DX_PI * 0.5f, pPlayer->GetRotInfo().GetRot().y + D3DX_PI, 0.0f), 0.1f));

			//爆発を見せたいので、カメラと注視点の距離を一定時間遠くする
			CManager::GetCamera()->ChengeLengthState(DBG_NEW CCameraLengthState_Gradually(300.0f, 0.1f, 60));
		}
		pWireHead->GetDrawInfo().SetUseDraw(false);              //ワイヤーの頭の描画をオフにする
		pPlayer->ChengeAttackMode(DBG_NEW CPlayerAttack_Dont()); //爆発し終わったので、攻撃状態を「なし」に戻す
	}

}
//======================================================================================================================================================